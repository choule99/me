This is a brief summary of how I became a software developer, how I caught the programming bug, and how that path led me to iOS development.

## Early Years

Like many kids of the '80s, my journey with computers began with games. I was fortunate to grow up in a family where technology was part of everyday life, so I had access to game consoles and computers from an early age.

I have vivid memories of playing on the ColecoVision, Atari 2600, NES, and SNES, and later discovering adventures like King's Quest and Space Quest on my dad's computer. My father tried to introduce me to programming back then, but I was more interested in playing than coding—and at seven or eight years old, I was probably a bit too young to fully appreciate it.

Note: Funny anecdote, my father found the original box for this computer in the attic, and noticed the price tag for a 16-color graphics card. Even back then, graphics cards were in the $1000 range.

## Meeting the Internet

I had early access to the internet thanks to my mother's university account, which meant learning the ropes over a very slow dial-up connection. I wasn't yet focused on programming, but the internet opened the door to something I didn't realize I needed: online gaming.

I spent countless hours playing cutting-edge titles of the time, eventually diving deep into games like Doom, Quake, Diablo, StarCraft, and Baldur's Gate (and many others).

## Catching the Programming Bug

In high school, I switched from music to a computing course. While I enjoyed guitar, I'd hit a plateau and was eager for a new challenge. Given my talent with computers, I thought the class would be easy; instead, it became transformative.

A teacher recognized my potential and gave me more ambitious assignments. Since I loved computer games, my assignments usually gravitated toward making my own rudimentary games. I became a fixture in the computer lab: writing code, testing my games, helping classmates, and trading tips with other motivated students. I was a total computer nerd, and I loved it.

## College

From there, the choice was obvious: I wanted to be a software developer. I enrolled in the Computer Science Technology program at Cégep Édouard-Montpetit and never looked back.

Yes, I trained in *C/C++*, *SQL*, and other technologies (many of which are now completely obsolete), but the most valuable takeaway was:

_There is always something to learn, always something to discover, and to maintain that edge, you need to practice constantly._

## Internship / First CS Job

I graduated in mid-2003 during a difficult job market following the dot-com bubble burst. Many talented graduates struggled to find roles. I was one of the fortunate few hired after my internship, joining Médiagrif (now known as mdfcommerce) as a *Java* developer for a suite of e-commerce sites across multiple business domains.

That first role was a crash course in becoming a professional engineer. School provided foundations, but the workplace taught me how to deliver production-grade software, collaborate effectively, and build good engineering habits. I was especially lucky to have mentors who shaped my early career; their guidance made me a better developer, and I remain grateful for their mentorship.

## From Java Developer to iOS Developer

For the first six years of my career, I worked as a back-end Java developer, using technologies like *J2EE*, *Spring Framework*, *Hibernate*, *Apache ActiveMQ*, *Apache Maven*, *Apache Ant*, *Gradle*, *Log4j*, *JBoss*, and *Apache Tomcat*. I learned a great deal, but eventually the challenges became less challenging, less interesting; I kind of outgrew the pure technical side of back-end development.

When Apple released the iPhone and opened up the iOS SDK, I embraced the opportunity to explore something new.

I had already switched to a Mac at home, so installing Xcode and learning Objective-C was an accessible next step—though it required a major mindset shift. After years of Java's garbage collection, returning to manual memory management felt like a step backward.

Developing for iOS 2 / 3 came with real constraints:

- No *ARC*; manual memory management
- No *storyboards*
- No Auto Layout—just plain x/y positioning
- No blocks (what we now call closures)
- Extensive use of pointers
- Limited device performance, where inefficiencies could make or break an app
- No readily available crash reporting (Crashlytics, Firebase, Sentry came later)

It truly felt like a new frontier. I learned a tremendous amount and still do: Apple's annual SDK releases build on prior foundations, demanding continuous adaptation and growth. iOS moved quickly—and that pace kept the work exciting and rewarding.

Note: You have to put Java into its historical context. After Java 8, Sun Microsystems barely changed the Java Stack for literally years. Oracle's stewardship did not help at first. Nowadays, it does look like the Java Ecosystem has bounced back, but back in those years, Java had been stagnating for years.

## The story since then... 

Since then, I have primarily focused on iOS development. While I have worked with other technology stacks over the years, my core expertise and passion consistently lead me back to iOS due to my strong preference for the platform.

Note: Regarding cross-platform mobile app frameworks (e.g., React Native, Flutter, Ionic, PhoneGap, Cordova), while I have not directly worked with these frameworks, I have observed that applications built with them often lack the native feel and optimal user experience of truly platform-native solutions. My preference remains with platform-native tools, as they enable the delivery of the most robust and performant experiences for end-users.